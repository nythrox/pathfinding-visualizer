{"version":3,"sources":["components/GridNode/GridNode.js","models/GridNodeModel.js","components/AppBloc.js","components/Navbar/Navbar.js","algorithms/dijkstra.js","components/Grid/Grid.js","components/App.js","serviceWorker.js","index.js","assets/edit-6-64.ico","assets/eraser-64.ico","assets/active_eraser.ico","assets/reset.png","assets/active_edit.ico","assets/play-6-64.ico"],"names":["GridNode","props","id","useState","isStart","setIsStart","isWall","setIsWall","isFinish","setIsFinish","toggleActive","col","row","window","tool","classes","ids","ref","useRef","useEffect","addRefToList","element","document","getElementById","classList","remove","className","onMouseLeave","canDrag","isDragging","toggleStart","toggleFinish","onMouseDown","target","onClick","canEdit","onMouseEnter","isMouseDown","GridNodeModel","distance","isVisited","previousNode","this","AppBloc","currentAlgorithm$","BehaviorSubject","gridValues$","Subject","playAnimation$","resetBoard$","gameState$","CurrentAlgorithmEnum","Object","freeze","dijkstra","aStar","animating","GameStateEnum","idle","rendering","unsubscribe","AppContext","React","createContext","Navbar","activeTool","setActiveTool","rows","setRows","cols","setCols","appBloc","useContext","next","width","src","play","alt","reset","active_pencil","pencil","active_eraser","eraser","type","value","placeholder","onChange","e","_rows","_cols","undefined","columns","grid","startNode","finishNode","visitedNodesInOrder","unvisitedNodes","nodes","node","push","getAllNodes","length","sortNodesByDistance","closestNode","shift","Infinity","updateUnvisitedNeighbors","sort","nodeA","nodeB","unvisitedNeighbors","neighbors","filter","neighbor","getUnvisitedNeighbors","Grid","x","y","startNodePos","finishNodePos","setGrid","gridSize","setGridSize","console","log","generateNewPhysicalGrid","playSubscription","subscribe","handleAnimateClick","resetSubscription","handleResetClick","gridSubscription","_value","generateNewPhysicalGridPreserveWalls","visualizeDijkstra","clearTimeoutId","setTimeout","i","clearTimeout","currentGrid","slice","nodesInShortestPathOrder","currentNode","unshift","getNodesInShortestPathOrder","animateDijkstra","animateShortestPath","others","getElementsByClassName","o","other","add","current","map","index","key","model","startPos","finishPos","currentRow","originalGrid","newGrid","newRow","App","onmousedown","onmouseup","gameStateSubscription","dispose","Boolean","location","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister","module","exports"],"mappings":"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","file":"static/js/main.7f873b6e.chunk.js","sourcesContent":["import React, { useState, useEffect, useImperativeHandle, useRef } from \"react\";\r\n\r\nconst GridNode = props => {\r\n  let id = props.id;\r\n  const [isStart, setIsStart] = useState(props.isStart);\r\n  const [isWall, setIsWall] = useState(props.isWall);\r\n  const [isFinish, setIsFinish] = useState(props.isFinish);\r\n\r\n  const handleMouseEnter = () => {\r\n    if (window.canDrag) {\r\n      if (window.isDragging) {\r\n        if (window.target === \"start\") {\r\n          props.toggleStart(props.col, props.row);\r\n          setIsStart(true);\r\n        } else {\r\n          props.toggleFinish(props.col, props.row);\r\n          setIsFinish(true);\r\n        }\r\n      } else {\r\n        if (window.isMouseDown && window.canEdit) {\r\n          toggleActive();\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  const handleClick = () => {\r\n    if (window.canEdit) toggleActive();\r\n  };\r\n\r\n  const toggleActive = () => {\r\n    props.toggleActive(props.col, props.row);\r\n    if (window.tool === \"addWall\") {\r\n      setIsWall(true);\r\n    } else {\r\n      setIsWall(false);\r\n    }\r\n  };\r\n\r\n  // function getRndInteger(min, max) {\r\n  //   return Math.floor(Math.random() * (max - min + 1) ) + min;\r\n  // }\r\n\r\n  let classes = \"grid-node\";\r\n  if (isStart) classes += \" start\";\r\n  if (isFinish) classes += \" finish\";\r\n  // if (isWall) classes += \" wall-\"+getRndInteger(1,3)\r\n  if (isWall) classes += \" wall\";\r\n  let ids = `node-${props.row}-${props.col}`;\r\n\r\n  let ref = useRef(null);\r\n\r\n  useEffect(() => {\r\n    setIsWall(props.isWall);\r\n    setIsStart(props.isStart);\r\n    setIsFinish(props.isFinish);\r\n    props.addRefToList(props.col, props.row, ref);\r\n    const element = document.getElementById(`node-${props.row}-${props.col}`);\r\n    element.classList.remove(\"visited\");\r\n    element.classList.remove(\"shortest-path\");\r\n    element.classList.remove(\"current-visited\");\r\n  }, [setIsFinish, setIsStart, setIsWall, props]);\r\n\r\n  const handleMouseDownDrag = () => {\r\n    if (window.canDrag) {\r\n      window.isDragging = true;\r\n      if (isStart) window.target = \"start\";\r\n      else window.target = \"finish\";\r\n    }\r\n  };\r\n\r\n  const handleMouseLeaveDrag = () => {\r\n    if (window.canDrag) {\r\n      if (window.isDragging) {\r\n        if (isStart) {\r\n          props.toggleStart(props.col, props.row);\r\n          setIsStart(false);\r\n        } else {\r\n          props.toggleFinish(props.col, props.row);\r\n          setIsFinish(false);\r\n        }\r\n      }\r\n    }\r\n  };\r\n  return (\r\n    <div\r\n      ref={ref}\r\n      className={classes}\r\n      id={ids}\r\n      onMouseLeave={isStart || isFinish ? handleMouseLeaveDrag : null}\r\n      onMouseDown={isStart || isFinish ? handleMouseDownDrag : null}\r\n      onClick={!(isStart || isFinish) ? handleClick : null}\r\n      onMouseEnter={!(isStart || isFinish) ? handleMouseEnter : null}\r\n    ></div>\r\n  );\r\n};\r\n\r\nexport default GridNode;\r\n","export class GridNodeModel {\r\n  constructor(\r\n    col,\r\n    row,\r\n    id,\r\n    isStart,\r\n    isFinish,\r\n    distance,\r\n    isVisited,\r\n    isWall,\r\n    previousNode,\r\n    ref\r\n  ) {\r\n    this.col = col;\r\n    this.row = row;\r\n    this.id = id;\r\n    this.isStart = isStart;\r\n    this.isFinish = isFinish;\r\n    this.distance = distance;\r\n    this.isVisited = isVisited;\r\n    this.isWall = isWall;\r\n    this.previousNode = previousNode;\r\n    this.ref = ref;\r\n  }\r\n}\r\n","import React, { createContext } from \"react\";\r\nimport { BehaviorSubject, Subject } from \"rxjs\";\r\n\r\nclass AppBloc {\r\n  //------------------streams\r\n  constructor() {\r\n    this.currentAlgorithm$ = new BehaviorSubject(1);\r\n    this.gridValues$ = new Subject();\r\n    this.playAnimation$ = new Subject();\r\n    this.resetBoard$ = new Subject();\r\n    this.gameState$ = new BehaviorSubject(1);\r\n\r\n    //------------------enums\r\n    this.CurrentAlgorithmEnum = Object.freeze({\r\n      dijkstra: 1,\r\n      aStar: 2,\r\n      animating: 3\r\n    });\r\n    this.GameStateEnum = Object.freeze({\r\n      idle:1,\r\n      rendering: 2,\r\n      animating: 3\r\n    });\r\n  \r\n}\r\n\r\n  dispose() {\r\n    this.currentAlgorithm$.unsubscribe();\r\n    this.playAnimation$.unsubscribe();\r\n    this.resetBoard$.unsubscribe();\r\n    this.gameState$.unsubscribe();\r\n  }\r\n}\r\nexport const AppContext = React.createContext(new AppBloc());\r\n","import pencil from \"../../assets/edit-6-64.ico\"; // Tell Webpack this JS file uses this image\r\nimport eraser from \"../../assets/eraser-64.ico\"; // Tell Webpack this JS file uses this image\r\nimport active_eraser from \"../../assets/active_eraser.ico\"; // Tell Webpack this JS file uses this image\r\nimport reset from \"../../assets/reset.png\"; // Tell Webpack this JS file uses this image\r\nimport active_pencil from \"../../assets/active_edit.ico\"; // Tell Webpack this JS file uses this image\r\nimport play from \"../../assets/play-6-64.ico\";\r\nimport React, {\r\n  useState,\r\n  useEffect,\r\n  useImperativeHandle,\r\n  useRef,\r\n  useContext\r\n} from \"react\";\r\nimport { AppContext } from \"../AppBloc\";\r\nimport { blockStatement } from \"@babel/types\";\r\nexport default function Navbar() {\r\n  const [activeTool, setActiveTool] = useState(\"pencil\");\r\n\r\n  const pencilClicked = () => {\r\n    window.tool = \"addWall\";\r\n    setActiveTool(\"pencil\");\r\n  };\r\n  const eraserClicked = () => {\r\n    window.tool = \"removeWall\";\r\n    setActiveTool(\"eraser\");\r\n  };\r\n  const [rows, setRows] = useState()\r\n  const [cols, setCols] = useState()\r\n\r\n  const appBloc = useContext(AppContext);\r\n\r\n\r\n  return (\r\n    <nav>\r\n      <ul>\r\n        <li\r\n          onClick={() => {\r\n            appBloc.playAnimation$.next(true);\r\n          }}\r\n        >\r\n          <img width=\"30px\" src={play} alt=\"play pathfinder\" />\r\n        </li>\r\n        <li\r\n          onClick={() => {\r\n            appBloc.resetBoard$.next(true);\r\n          }}\r\n        >\r\n          <img width=\"40px\" src={reset} alt=\"reset grid\" />\r\n        </li>\r\n        <li>\r\n          <img\r\n            src={activeTool === \"pencil\" ? active_pencil : pencil}\r\n            width=\"30\"\r\n            alt=\"draw wall\"\r\n            onClick={pencilClicked}\r\n          />\r\n        </li>\r\n        <li>\r\n          <img\r\n            src={activeTool === \"eraser\" ? active_eraser : eraser}\r\n            width=\"30\"\r\n            alt=\"remove wall\"\r\n            onClick={eraserClicked}\r\n          />\r\n        </li>\r\n        <li>\r\n          rows:\r\n          <input type=\"number\" value={rows} placeholder=\"20\"onChange={(e)=>{setRows(e.target.value)}} />\r\n          cols:\r\n          <input type=\"number\" value={cols} placeholder=\"50\" onChange={(e)=>{setCols(e.target.value)}} />\r\n          <input\r\n            type=\"submit\"\r\n            value=\"create grid\"\r\n            onClick={() => {\r\n              let _rows = 20;\r\n              let _cols = 50;\r\n              if (!(rows === undefined || rows === \"\")) _rows = rows;\r\n              if (!(cols === undefined || cols === \"\")) _cols = cols;\r\n              if (_rows >= 2 && _cols >= 2) {\r\n                appBloc.gridValues$.next({ rows: _rows, columns: _cols });\r\n              }\r\n            }}\r\n          />\r\n        </li>\r\n      </ul>\r\n    </nav>\r\n  );\r\n}\r\n","export function dijkstra(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n  startNode.distance = 0;\r\n  const unvisitedNodes = getAllNodes(grid);\r\n  while (!!unvisitedNodes.length) {\r\n    sortNodesByDistance(unvisitedNodes);\r\n    const closestNode = unvisitedNodes.shift(); //gets first element\r\n    // If we encounter a wall, we skip it.\r\n    if (closestNode.isWall) continue;\r\n    // If the closest node is at a distance of infinity,\r\n    // we must be trapped and should therefore stop.\r\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n    closestNode.isVisited = true;\r\n    visitedNodesInOrder.push(closestNode);\r\n    if (closestNode === finishNode) return visitedNodesInOrder;\r\n    updateUnvisitedNeighbors(closestNode, grid);\r\n  }\r\n}\r\n\r\nfunction sortNodesByDistance(unvisitedNodes) {\r\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid) {\r\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n  for (const neighbor of unvisitedNeighbors) {\r\n    neighbor.distance = node.distance + 1;\r\n    neighbor.previousNode = node;\r\n  }\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n  const neighbors = [];\r\n  const { col, row } = node;\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n  return neighbors.filter(neighbor => !neighbor.isVisited);\r\n}\r\n\r\nfunction getAllNodes(grid) {\r\n  const nodes = [];\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      nodes.push(node);\r\n    }\r\n  }\r\n  return nodes;\r\n}\r\n\r\n// Backtracks from the finishNode to find the shortest path.\r\n// Only works when called *after* the dijkstra method above.\r\nexport function getNodesInShortestPathOrder(finishNode) {\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n","import React, { useState, useEffect, useContext } from \"react\";\r\nimport { GridNodeModel } from \"../../models/GridNodeModel\";\r\nimport GridNode from \"../GridNode/GridNode\";\r\nimport {\r\n  dijkstra,\r\n  getNodesInShortestPathOrder\r\n} from \"../../algorithms/dijkstra\";\r\nimport { AppContext } from \"../AppBloc\";\r\nimport { blockStatement } from \"@babel/types\";\r\n\r\nfunction Grid(props) {\r\n  const [startNodePos, setStartNodePos] = useState({ x: 5, y: 7 });\r\n  const [finishNodePos, setFinishNodePos] = useState({ x: 20, y: 8 });\r\n  const [grid, setGrid] = useState([]); //obs: I am directly mutating state because of performance issues for having so many tiles\r\n  const appBloc = useContext(AppContext);\r\n  const [gridSize, setGridSize] = useState({\r\n    columns: 50,\r\n    rows: 20\r\n  });\r\n  useEffect(() => {\r\n    console.log(\"started\");\r\n    if (grid.length === 0) {\r\n      setGrid(\r\n        generateNewPhysicalGrid(\r\n          props.rows,\r\n          props.columns,\r\n          startNodePos,\r\n          finishNodePos\r\n        )\r\n      );\r\n    }\r\n    const playSubscription = appBloc.playAnimation$.subscribe(e => {\r\n      handleAnimateClick();\r\n    });\r\n    const resetSubscription = appBloc.resetBoard$.subscribe(e => {\r\n      handleResetClick();\r\n    });\r\n    const gridSubscription = appBloc.gridValues$.subscribe(e => {\r\n      setGridSize(e);\r\n      setGrid(\r\n        generateNewPhysicalGrid(e.rows, e.columns, startNodePos, finishNodePos)\r\n      );\r\n    });\r\n    return () => {\r\n      playSubscription.unsubscribe();\r\n      resetSubscription.unsubscribe();\r\n      gridSubscription.unsubscribe();\r\n    };\r\n  }, [grid, props, startNodePos, finishNodePos, appBloc]);\r\n\r\n  const handleAnimateClick = () => {\r\n    if (appBloc.gameState$._value === appBloc.GameStateEnum.idle) {\r\n      appBloc.gameState$.next(appBloc.GameStateEnum.rendering);\r\n      setGrid(generateNewPhysicalGridPreserveWalls(grid));\r\n      console.log(\"set grid\");\r\n      appBloc.gameState$.next(appBloc.GameStateEnum.animating);\r\n      visualizeDijkstra();\r\n    }\r\n  };\r\n\r\n  const handleResetClick = () => {\r\n    var clearTimeoutId = setTimeout(\";\", 0); //timeout to clear all other timeouts\r\n    for (var i = 0; i < clearTimeoutId; i++) {\r\n      clearTimeout(i);\r\n    }\r\n\r\n    setGrid(\r\n      generateNewPhysicalGrid(\r\n        gridSize.rows,\r\n        gridSize.columns,\r\n        startNodePos,\r\n        finishNodePos\r\n      )\r\n    );\r\n    appBloc.gameState$.next(appBloc.GameStateEnum.idle);\r\n  };\r\n\r\n  const visualizeDijkstra = () => {\r\n    const currentGrid = grid.slice();\r\n    const visitedNodesInOrder = dijkstra(\r\n      currentGrid,\r\n      currentGrid[startNodePos.y][startNodePos.x],\r\n      currentGrid[finishNodePos.y][finishNodePos.x]\r\n    );\r\n    let nodesInShortestPathOrder = getNodesInShortestPathOrder(\r\n      currentGrid[finishNodePos.y][finishNodePos.x]\r\n    );\r\n    animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder);\r\n  };\r\n\r\n  const toggleActive = (col, row) => {\r\n    if (window.tool === \"addWall\") {\r\n      grid[row][col].isWall = true;\r\n    } else {\r\n      grid[row][col].isWall = false;\r\n    }\r\n  };\r\n\r\n  const toggleStart = (col, row) => {\r\n    if (grid[row][col].isStart === true) {\r\n      grid[row][col].isStart = false;\r\n    } else {\r\n      startNodePos.x = col;\r\n      startNodePos.y = row;\r\n      grid[row][col].isStart = true;\r\n    }\r\n  };\r\n\r\n  const toggleFinish = (col, row) => {\r\n    if (grid[row][col].isFinish === true) {\r\n      grid[row][col].isFinish = false;\r\n    } else {\r\n      finishNodePos.x = col;\r\n      finishNodePos.y = row;\r\n      grid[row][col].isFinish = true;\r\n    }\r\n  };\r\n\r\n  const addRefToList = (col, row, ref) => {\r\n    grid[row][col].ref = ref;\r\n  };\r\n\r\n  const animateDijkstra = (visitedNodesInOrder, nodesInShortestPathOrder) => {\r\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n      const node = visitedNodesInOrder[i];\r\n      if (i === visitedNodesInOrder.length) {\r\n        setTimeout(() => {\r\n          animateShortestPath(nodesInShortestPathOrder);\r\n        }, 25 * i);\r\n        return;\r\n      }\r\n\r\n      setTimeout(() => {\r\n        var others = document.getElementsByClassName(\"current-visited\");\r\n        if (others.length > 0) {\r\n          for (let o = 0; o < others.length; o++) {\r\n            var other = others[o];\r\n            if (other !== undefined) {\r\n              other.classList.remove(\"current-visited\");\r\n              other.classList.add(\"visited\");\r\n            }\r\n          }\r\n        }\r\n        node.ref.current.classList.add(\"current-visited\");\r\n      }, 25 * i);\r\n    }\r\n  };\r\n\r\n  const animateShortestPath = nodesInShortestPathOrder => {\r\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n      if (i === nodesInShortestPathOrder.length - 1) {\r\n        appBloc.gameState$.next(appBloc.GameStateEnum.idle);\r\n      }\r\n      setTimeout(() => {\r\n        const node = nodesInShortestPathOrder[i];\r\n        node.ref.current.classList.add(\"shortest-path\");\r\n      }, 30 * i);\r\n    }\r\n  };\r\n  return (\r\n    <div className=\"grid-container\">\r\n      {grid.map((row, index) => (\r\n        <div className=\"grid-row\" key={index}>\r\n          {row.map(node => (\r\n            <GridNode\r\n              key={node.id}\r\n              col={node.col}\r\n              row={node.row}\r\n              id={node.id}\r\n              isStart={node.isStart}\r\n              isFinish={node.isFinish}\r\n              isWall={node.isWall}\r\n              toggleActive={toggleActive}\r\n              addRefToList={addRefToList}\r\n              model={node}\r\n              toggleFinish={toggleFinish}\r\n              toggleStart={toggleStart}\r\n            />\r\n          ))}\r\n        </div>\r\n      ))}\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Grid;\r\n\r\nconst generateNewPhysicalGrid = (\r\n  rows,\r\n  columns,\r\n  startNodePos,\r\n  finishNodePos\r\n) => {\r\n  let grid = [];\r\n  let id = 0;\r\n  let startPos = startNodePos;\r\n  let finishPos = finishNodePos;\r\n  if (startNodePos.x >= columns) {\r\n    startPos.x = 0;\r\n  }\r\n  if (startNodePos.y >= rows) {\r\n    startPos.y = 0;\r\n  }\r\n  if (finishNodePos.x >= columns) {\r\n    finishPos.x = columns - 1;\r\n  }\r\n  if (finishNodePos.y >= rows) {\r\n    finishPos.y = rows - 1;\r\n  }\r\n  for (let row = 0; row < rows; row++) {\r\n    let currentRow = [];\r\n    for (let col = 0; col < columns; col++) {\r\n      currentRow.push(\r\n        new GridNodeModel(\r\n          col, //col\r\n          row, //row\r\n          id, //id\r\n          col === startPos.x && row === startPos.y, //isStart\r\n          col === finishPos.x && row === finishPos.y, //isEnd\r\n          Infinity, //distance\r\n          false, //isVisited\r\n          false, //isWall\r\n          null, //previousNode\r\n          null //ref\r\n        )\r\n      );\r\n      id++;\r\n    }\r\n    grid.push(currentRow);\r\n  }\r\n  return grid;\r\n};\r\nconst generateNewPhysicalGridPreserveWalls = originalGrid => {\r\n  let newGrid = [];\r\n  for (let row = 0; row < originalGrid.length; row++) {\r\n    let newRow = [];\r\n    for (let col = 0; col < originalGrid[row].length; col++) {\r\n      let node = originalGrid[row][col];\r\n      newRow.push(\r\n        new GridNodeModel(\r\n          node.col,\r\n          node.row,\r\n          node.id,\r\n          node.isStart,\r\n          node.isFinish,\r\n          Infinity,\r\n          false,\r\n          node.isWall,\r\n          null,\r\n          node.ref\r\n        )\r\n      );\r\n    }\r\n    newGrid.push(newRow);\r\n  }\r\n  return newGrid;\r\n};\r\n","import React, { useState, useEffect, useContext } from \"react\";\nimport GridNode from \"./GridNode/GridNode\";\nimport { GridNodeModel } from \"../models/GridNodeModel\";\nimport Navbar from \"./Navbar/Navbar\";\nimport { AppContext } from \"./AppBloc\";\nimport Grid from \"./Grid/Grid.js\";\n\nfunction App() {\n  const appBloc = useContext(AppContext);\n  useEffect(() => {\n    window.canEdit = false;\n    window.tool = \"addWall\";\n    document.onmousedown = () => {\n      window.isMouseDown = true;\n    };\n    document.onmouseup = () => {\n      window.isMouseDown = false;\n      if (window.isDragging)\n      window.isDragging = false;\n    };\n    const gameStateSubscription = appBloc.gameState$.subscribe(e => {\n      if (e === appBloc.GameStateEnum.idle) {\n        window.canDrag = true;\n        window.canEdit = true;\n      } else {\n        window.canDrag = false;\n        window.canEdit = false;\n      }\n    });\n    return () => {\n      appBloc.dispose();\n      gameStateSubscription.unsubscribe();\n    };\n  });\n  return (\n    <div className=\"App\">\n      <Navbar />\n      <div className=\"pixelart-to-css\"></div>\n      <Grid columns={50} rows={20} />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './components/App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","module.exports = __webpack_public_path__ + \"static/media/edit-6-64.5208802d.ico\";","module.exports = __webpack_public_path__ + \"static/media/eraser-64.34c544ba.ico\";","module.exports = __webpack_public_path__ + \"static/media/active_eraser.a346124c.ico\";","module.exports = __webpack_public_path__ + \"static/media/reset.111f68e6.png\";","module.exports = __webpack_public_path__ + \"static/media/active_edit.c35285a2.ico\";","module.exports = __webpack_public_path__ + \"static/media/play-6-64.d2a1ab54.ico\";"],"sourceRoot":""}